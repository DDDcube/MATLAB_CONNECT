// Copyright 2024 The MathWorks, Inc.
import * as vscode from 'vscode';
import { LanguageClient } from 'vscode-languageclient/node'
import Notification from '../Notifications'

import LineRangeTree from './LineRangeTree';

import { blueBorderTopDecoration, blueBorderBottomDecoration, greyBorderTopDecoration, greyBorderBottomDecoration, fontWeightBoldDecoration } from './Decorations';
import { StartAndEndLines, SectionsData, TopAndBottomRanges, StylingRanges } from './StylingInterfaces';
const sectionsCacheByPath = new Map<string, SectionsData>();
let previousFocusedEditor: vscode.TextEditor | undefined;

class SectionStylingService {
    constructor (private readonly context: vscode.ExtensionContext) {}

    initialize (client: LanguageClient): void {
        this.context.subscriptions.push(client.onNotification(Notification.MatlabSections, (data) => this._onNewSectionsGenerated(data)))
        // Listen to cursor change to highlight the section
        this.context.subscriptions.push(vscode.window.onDidChangeTextEditorSelection((event) => this._handleTextEditorSelectionChange(event)));

        // Clear the active blue borders for focus out
        this.context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor((editor) => this._handleEditorFocusChange(editor)))
        this.context.subscriptions.push(vscode.window.onDidChangeWindowState((windowFocusState) => this._handleWindowLostFocus(windowFocusState)));

        this.context.subscriptions.push(vscode.workspace.onDidChangeTextDocument((event) => this._onDocumentChange(event)));
        this.context.subscriptions.push(vscode.workspace.onDidCloseTextDocument((document: vscode.TextDocument) => this._onDocumentClose(document)));
    }

    private _onDocumentChange (event: vscode.TextDocumentChangeEvent): void {
        const filePath = decodeURIComponent(event.document.uri.toString());
        const sectionCache = sectionsCacheByPath.get(filePath);
        if (sectionCache === undefined || event.contentChanges.length === 0) {
            return
        }
        // As content changes enable isSectionCreationInProgress flag, so cursor changes will not renders sections with cache.
        // This flag will reset once the sections are regenerated by matlab
        sectionCache.isSectionCreationInProgress = true;
    }

    private _onNewSectionsGenerated (sectionsData: SectionsData): void {
        const decodedUri = decodeURIComponent(sectionsData.uri);
        const editorInTheWindow: vscode.TextEditor | undefined = vscode.window.visibleTextEditors.find((editor) => {
            const textEditorURI = this._getDecodedURI(editor)
            return (textEditorURI === decodedUri);
        });
        if (editorInTheWindow === undefined) {
            return
        }
        this._preProcessAndSaveSectionByEditor(sectionsData, decodedUri, editorInTheWindow);
        this._postProcessSectionsData(sectionsData, editorInTheWindow);
    }

    private _preProcessAndSaveSectionByEditor (sectionsData: SectionsData, decodedUri: string, editorInTheWindow: vscode.TextEditor): void {
        const { sectionRanges } = sectionsData;
        sectionRanges.sort((a: vscode.Range, b: vscode.Range) => a.start.line - b.start.line);
        const isSectionAddedAtStart = this._addFirstSectionIfNotExists(sectionRanges);
        // Creates a tree of sections and saves it in the sectionsData cache
        // Used for retrieving the active section to highlight
        sectionsData.sectionsTree = new LineRangeTree(sectionRanges);
        sectionsData.isSectionCreationInProgress = false;
        sectionsData.implictSectionAtStart = isSectionAddedAtStart;
        sectionsCacheByPath.set(decodedUri, sectionsData);
    }

    // Add first section if not exists otherwise the cursor will not highlight the section
    private _addFirstSectionIfNotExists (sectionRanges: vscode.Range[]): boolean {
        if (sectionRanges.length === 0) {
            return false;
        }
        const firstSection = sectionRanges[0];
        const startLine = firstSection?.start?.line;
        if (startLine === 0) {
            return false;
        }
        const newStartLine = 0;
        const newEndLine = startLine - 1;
        const range = new vscode.Range(newStartLine, 0, newEndLine, 0);
        sectionRanges.unshift(range);
        return true;
    }

    private _postProcessSectionsData (sectionsData: SectionsData, editorInTheWindow: vscode.TextEditor): void {
        const { sectionRanges } = sectionsData;
        if (sectionRanges !== undefined && sectionRanges.length === 0) {
            // If there are no sections, clear the decorations
            this._clearDecorations(editorInTheWindow);
            return
        }
        const activeEditor = this._getActiveEditor();
        if (activeEditor !== undefined && activeEditor === editorInTheWindow) {
            const cursorPosition = editorInTheWindow.selection.active;
            if (cursorPosition !== undefined) {
                // Highlight active sections to blue and inactive sections to grey
                this._highlightSections(activeEditor, sectionsData, cursorPosition);
                return;
            }
        }
        // Highlight all sections to grey
        this._highlightSections(editorInTheWindow, sectionsData, null);
    }

    private _clearDecorations (editorInTheWindow: vscode.TextEditor): void {
        this._setDecorations(editorInTheWindow, { blue: { top: [], bottom: [] }, grey: { top: [], bottom: [] } }, []);
    }

    private _getDecodedURI (editor: vscode.TextEditor): string {
        return decodeURIComponent(editor.document.uri.toString())
    }

    private _handleWindowLostFocus (windowState: vscode.WindowState): void {
        if (!windowState.focused) {
            const activeEditor = this._getActiveEditor();
            // Clear the blue borders when the window lost focus
            if (activeEditor != null) {
                this._clearBlueDecorations(activeEditor);
            }
        }
    }

    private _handleEditorFocusChange (editor: vscode.TextEditor | undefined): void {
        if (previousFocusedEditor !== undefined && previousFocusedEditor !== editor) {
            // Clear the blue borders for previous editors when new editor is focused
            this._clearBlueDecorations(previousFocusedEditor);
        }
        previousFocusedEditor = editor;
    }

    private _handleTextEditorSelectionChange (event: vscode.TextEditorSelectionChangeEvent): void {
        const editor = event.textEditor;
        const cursorPosition = editor.selection.active;
        const editorSections = sectionsCacheByPath.get(this._getDecodedURI(editor));
        if (editorSections?.isSectionCreationInProgress === true) {
            // Don't highlight sections if section creation is in progress
            // This will create sections with cache data which will be wrong
            return;
        }

        if (editorSections != null) {
            // Don't highlight sections if there is an error
            this._highlightSections(editor, editorSections, cursorPosition);
        }
    }

    private _onDocumentClose (document: vscode.TextDocument): void {
        // Remove sections from cache when document is closed
        const decodedURI = decodeURIComponent(document.uri.toString());
        sectionsCacheByPath.delete(decodedURI);
    }

    private _clearBlueDecorations (previousEditor: vscode.TextEditor): void {
        const decodedUri = this._getDecodedURI(previousEditor);
        const sections = sectionsCacheByPath.get(decodedUri);
        if (sections !== undefined && sections.isSectionCreationInProgress === false) {
            this._highlightSections(previousEditor, sections, null);
        }
    }

    private _getActiveEditor (): vscode.TextEditor | undefined {
        return vscode.window.activeTextEditor;
    }

    /**
     * Highlights sections in the editor with grey lines if no cursor is present
     * Highlights active section (cursor present) in the editor with blue lines and others in grey line
     * Bold the first line of the sections
     */
    private _highlightSections (editor: vscode.TextEditor, sections: SectionsData, activeCursorPosition: vscode.Position | null): void {
        const startAndEndLines = this._sectionsToStartAndEndLines(sections.sectionRanges);
        const allStartLinesRange = this._generateRanges(startAndEndLines.startLines);
        const lastLineinSection = startAndEndLines.endLines.sort((a, b) => a - b)[startAndEndLines.endLines.length - 1];

        let stylingRanges: StylingRanges;
        if (activeCursorPosition !== null) {
            let cursorPositionLine = activeCursorPosition.line;
            if (cursorPositionLine > lastLineinSection) {
                cursorPositionLine = lastLineinSection
            }
            const focusedSectionRange: vscode.Range | undefined = this._findFocusedSectionRange(sections, cursorPositionLine);
            if (focusedSectionRange !== undefined) {
                stylingRanges = this._getBlueAndGreyRanges(startAndEndLines, focusedSectionRange);
            } else {
                stylingRanges = { blue: { top: [], bottom: [] }, grey: this._getGreyRanges(startAndEndLines) };
            }
        } else {
            stylingRanges = { blue: { top: [], bottom: [] }, grey: this._getGreyRanges(startAndEndLines) };
        }
        this._filterFirstAndLastSection(stylingRanges, lastLineinSection, editor.document);

        if (sections.implictSectionAtStart === true) {
            // Remove as the first section is implicit
            allStartLinesRange.shift();
        }
        this._setDecorations(editor, stylingRanges, allStartLinesRange);
    }

    private _getBlueAndGreyRanges (startAndEndLines: StartAndEndLines, focusedSectionRange: vscode.Range): StylingRanges {
        const focusedStartLine = focusedSectionRange.start.line;
        const focusedEndLine = focusedSectionRange.end.line;
        const { startLines, endLines } = startAndEndLines;

        const startLinesWithoutFocusLine = startLines.filter((startLine) => {
            // Remove the start lines if the start is coinciding with
            // focus start or
            // start line is after the focused end line
            // so we can color them blue
            return !((startLine === focusedStartLine) || (startLine === (focusedEndLine + 1)));
        });

        const endLinesWithoutFocusLine = endLines.filter((endLine) => {
            // Remove the end lines if the end is coinciding with
            // focus end or
            // before the focus end line or
            // is it already part of the start lines
            return !(endLine === focusedEndLine ||
                endLine === (focusedStartLine - 1) ||
                startLines.includes(endLine + 1));
        });

        const blue: TopAndBottomRanges = { top: [], bottom: [] };

        const isTheEndLineAdjacentToStartLine = startLines.includes(focusedEndLine + 1)
        const topBordersToStyle = [focusedStartLine];
        const bottomLineNumbersToStyle = [];

        if (isTheEndLineAdjacentToStartLine) {
            // Style using top borders if the end line is adjacent to the start line
            topBordersToStyle.push(focusedEndLine + 1)
        } else {
            bottomLineNumbersToStyle.push(focusedEndLine)
        }
        blue.top = this._generateRanges(topBordersToStyle);
        blue.bottom = this._generateRanges(bottomLineNumbersToStyle);

        return {
            blue,
            grey: {
                top: this._generateRanges(startLinesWithoutFocusLine),
                bottom: this._generateRanges(endLinesWithoutFocusLine)
            }
        };
    }

    private _getGreyRanges (startAndEndLines: StartAndEndLines): TopAndBottomRanges {
        const { startLines, endLines } = startAndEndLines
        const endLinesFiltered = endLines.filter((endLine) => !startLines.includes(endLine + 1));
        return { top: this._generateRanges(startLines), bottom: this._generateRanges(endLinesFiltered) };
    }

    private _setDecorations (editor: vscode.TextEditor, stylingRange: StylingRanges, allStartLinesRange: vscode.Range[]): void {
        editor.setDecorations(blueBorderTopDecoration, stylingRange.blue.top);
        editor.setDecorations(blueBorderBottomDecoration, stylingRange.blue.bottom);
        editor.setDecorations(greyBorderTopDecoration, stylingRange.grey.top);
        editor.setDecorations(greyBorderBottomDecoration, stylingRange.grey.bottom);
        editor.setDecorations(fontWeightBoldDecoration, allStartLinesRange);
    }

    private _generateRanges (lines: number[]): vscode.Range[] {
        return lines.map((line: number) => new vscode.Range(line, 0, line, Infinity));
    }

    private _findFocusedSectionRange (sections: SectionsData, lineNumber: number): vscode.Range | undefined {
        let activeSection: vscode.Range | undefined;
        if (lineNumber !== undefined && sections.sectionsTree !== undefined) {
            activeSection = sections.sectionsTree.find(lineNumber);
        }
        return activeSection;
    }

    private _sectionsToStartAndEndLines (sectionRanges: vscode.Range[]): StartAndEndLines {
        const startLines = new Set<number>();
        const endLines = new Set<number>();
        sectionRanges.forEach((sectionRange: vscode.Range) => {
            const startingIndex = sectionRange.start.line;
            const endingIndex = sectionRange.end.line;
            startLines.add(startingIndex);
            endLines.add(endingIndex);
        });
        return { startLines: Array.from(startLines), endLines: Array.from(endLines) };
    }

    private _filterFirstAndLastSection (stylingRanges: StylingRanges, endingLineOfSections: number, document: vscode.TextDocument): void {
        const filterByLineNumber = (lineNumber: number) => (position: vscode.Range): boolean => !(position.start.line === lineNumber);
        const startingLineOfDocument = 0;
        stylingRanges.blue.top = stylingRanges.blue.top.filter(filterByLineNumber(startingLineOfDocument));
        stylingRanges.grey.top = stylingRanges.grey.top.filter(filterByLineNumber(startingLineOfDocument));
        stylingRanges.blue.bottom = stylingRanges.blue.bottom.filter(filterByLineNumber(endingLineOfSections));
        stylingRanges.grey.bottom = stylingRanges.grey.bottom.filter(filterByLineNumber(endingLineOfSections));
    }
}

export default SectionStylingService;
